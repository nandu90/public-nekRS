//
// nekRS User Defined File
//
#include <math.h>
#include "udf.hpp"
#include "randomVector.hpp"

static dfloat Stk;
static dlong nParticles;
static dlong nParticlesGlobal;
static occa::kernel particleRHSKernel;
static lpm_t* particles = nullptr;

/* UDF Functions */                                                      

void UDF_LoadKernels(occa::properties& kernelInfo)
{
  particleRHSKernel = oudfBuildKernel(kernelInfo, "particleRHS");
  lpm_t::registerKernels(kernelInfo);
}

void UDF_Setup0(MPI_Comm comm, setupAide &options)
{
  int commSize;
  MPI_Comm_size(comm, &commSize);

  int rank;
  MPI_Comm_rank(comm, &rank);

  platform->par->extract("casedata", "stk", Stk);
  platform->par->extract("casedata", "nparticles", nParticlesGlobal);

  nParticles = nParticlesGlobal / commSize;

  // distribute remaining particles
  const int remainder = nParticlesGlobal % commSize;
  if(rank < remainder)
    nParticles++;
}

void particleRHS(nrs_t *nrs, lpm_t *lpm, dfloat time, occa::memory o_y, void *userdata, occa::memory o_ydot)
{
  auto offset = lpm->fieldOffset();

  // evaluate fluid fields at particle positions
  lpm->interpolate();

  auto o_Uinterp = lpm->getInterpField("fluid_velocity");

  particleRHSKernel(lpm->size(), offset, o_y, lpm->o_prop, o_Uinterp, o_ydot);
}

void UDF_Setup(nrs_t *nrs)
{
  auto * mesh = nrs->meshV;

  particles = new lpm_t(nrs, nrs->nEXT, 0.0);
  particles->setUserRHS(particleRHS);

  // register fluid velocity as an interpolated quantity
  particles->registerInterpField("fluid_velocity", nrs->NVfields, nrs->o_U);

  // register particle velocity as DOF
  particles->registerDOF(nrs->NVfields, "velocity");

  // register Stokes number as a property
  particles->registerProp("stokes_number");

  particles->construct(nParticles);

  // generate random particles in the domain
  auto xPart = randomVector<dfloat>(nParticles);
  auto yPart = randomVector<dfloat>(nParticles);
  auto zPart = randomVector<dfloat>(nParticles);

  const auto xMin = platform->linAlg->min(mesh->Nlocal, mesh->o_x, platform->comm.mpiComm);
  const auto yMin = platform->linAlg->min(mesh->Nlocal, mesh->o_y, platform->comm.mpiComm);
  const auto zMin = platform->linAlg->min(mesh->Nlocal, mesh->o_z, platform->comm.mpiComm);

  const auto xMax = platform->linAlg->max(mesh->Nlocal, mesh->o_x, platform->comm.mpiComm);
  const auto yMax = platform->linAlg->max(mesh->Nlocal, mesh->o_y, platform->comm.mpiComm);
  const auto zMax = platform->linAlg->max(mesh->Nlocal, mesh->o_z, platform->comm.mpiComm);

  for(int pid = 0; pid < nParticles; ++pid){
    const auto x = xPart[pid];
    const auto y = yPart[pid];
    const auto z = zPart[pid];

    xPart[pid] = xMin + (xMax - xMin)*x;
    yPart[pid] = yMin + (yMax - yMin)*y;
    zPart[pid] = zMin + (zMax - zMin)*z;
  }

  // set initial particle positions
  const auto particleOffset = particles->fieldOffset();
  auto o_xPart = particles->o_y + 0 * particleOffset * sizeof(dfloat);
  auto o_yPart = particles->o_y + 1 * particleOffset * sizeof(dfloat);
  auto o_zPart = particles->o_y + 2 * particleOffset * sizeof(dfloat);

  o_xPart.copyFrom(xPart.data(), nParticles*sizeof(dfloat));
  o_yPart.copyFrom(yPart.data(), nParticles*sizeof(dfloat));
  o_zPart.copyFrom(zPart.data(), nParticles*sizeof(dfloat));

  // set Stokes number
  platform->linAlg->fill(nParticles, Stk, particles->o_prop);

}

void UDF_ExecuteStep(nrs_t *nrs, dfloat time, int tstep)
{
  if (!nrs->lastStep) {
    particles->integrate(time, time + nrs->dt[0], tstep);
  }

  if (nrs->isOutputStep) {
    nek::ocopyToNek(time, tstep);
    nek::userchk(); // compute lambda2
    nek::ocopyFromNek(time);

    particles->writeFld(time);
  }
}
